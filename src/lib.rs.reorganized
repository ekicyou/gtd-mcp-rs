//! GTD MCP Server Library
//!
//! This library provides a Model Context Protocol (MCP) server for GTD (Getting Things Done)
//! task management. It implements the GTD methodology with support for tasks, projects,
//! and contexts, with automatic Git-based version control.
//!
//! # Architecture
//!
//! The library follows a 3-layer architecture:
//! - **MCP Layer**: `GtdServerHandler` - Handles MCP protocol communication
//! - **Domain Layer**: `gtd` module - Core GTD data models and business logic
//! - **Persistence Layer**: `storage` module - File-based TOML storage with Git sync
//!
//! # Example
//!
//! ```no_run
//! use gtd_mcp::GtdServerHandler;
//! use anyhow::Result;
//!
//! #[tokio::main]
//! async fn main() -> Result<()> {
//!     let handler = GtdServerHandler::new("gtd.toml", false)?;
//!     // Use handler with MCP server...
//!     Ok(())
//! }
//! ```

pub mod formatting;
pub mod git_ops;
pub mod gtd;
pub mod handlers;
pub mod migration;
pub mod storage;
pub mod validation;

use anyhow::Result;

use mcp_attr::Result as McpResult;
use mcp_attr::server::{McpServer, mcp_server};
use std::sync::Mutex;

// Re-export for integration tests (McpServer trait already in scope above)

// Re-export commonly used types
pub use git_ops::GitOps;
pub use gtd::{GtdData, Nota, NotaStatus, local_date_today};
pub use storage::Storage;

/// MCP Server handler for GTD task management
///
/// Provides an MCP interface to GTD functionality including task management,
/// project tracking, and context organization. All changes are automatically
/// persisted to a TOML file and optionally synchronized with Git.
pub struct GtdServerHandler {
    pub(crate) data: Mutex<GtdData>,
    pub(crate) storage: Storage,
}

impl GtdServerHandler {
    /// Create a new GTD server handler
    ///
    /// # Arguments
    /// * `storage_path` - Path to the GTD data file (TOML format)
    /// * `sync_git` - Enable automatic Git synchronization
    ///
    /// # Returns
    /// Result containing the handler or an error
    ///
    /// # Example
    /// ```no_run
    /// # use gtd_mcp::GtdServerHandler;
    /// # use anyhow::Result;
    /// # fn main() -> Result<()> {
    /// let handler = GtdServerHandler::new("gtd.toml", false)?;
    /// # Ok(())
    /// # }
    /// ```
    pub fn new(storage_path: &str, sync_git: bool) -> Result<Self> {
        let storage = Storage::new(storage_path, sync_git);
        let data = Mutex::new(storage.load()?);
        Ok(Self { data, storage })
    }

    /// Save GTD data with a default commit message.
    ///
    /// Persists the current in-memory GTD data to disk using the default commit message
    /// defined in `Storage::save()`, which is "Update GTD data".
    /// This is typically called by handler modules after modifying GTD data,
    /// following the MCP tool implementation pattern.
    #[allow(dead_code)]
    pub(crate) fn save_data(&self) -> Result<()> {
        let data = self.data.lock().unwrap();
        self.storage.save(&data)?;
        Ok(())
    }

    /// Save GTD data with a custom commit message.
    ///
    /// Persists the current GTD data to disk and creates a Git commit using the provided message.
    ///
    /// # Arguments
    /// * `message` - Commit message to use for the Git version history.
    pub(crate) fn save_data_with_message(&self, message: &str) -> Result<()> {
        let data = self.data.lock().unwrap();
        self.storage.save_with_message(&data, message)?;
        Ok(())
    }
}

impl Drop for GtdServerHandler {
    fn drop(&mut self) {
        // Push to git on shutdown if sync is enabled
        if let Err(e) = self.storage.shutdown() {
            eprintln!("Warning: Shutdown git sync failed: {}", e);
        }
    }
}

/// GTD task management server implementing David Allen's methodology.
/// Workflow: Capture(inbox) → Review(list) → Clarify(update) → Organize(change_status) → Do → Purge(empty_trash)
///
/// **Statuses**: inbox(start) | next_action(ready) | waiting_for(blocked) | later(deferred) | calendar(dated) | someday(maybe) | done | reference | trash
/// **Types**: task | project(multi-step) | context(@location)
/// **IDs**: Use meaningful strings (e.g., "call-john", "website-redesign")
#[mcp_server]
impl McpServer for GtdServerHandler {
    /// **Purge**: Permanently delete all trashed items. Run weekly.
    /// **When**: Part of weekly review - trash items first with change_status, then purge.
    /// **Safety**: Checks references to prevent broken links.
    #[tool]
    async fn empty_trash(&self) -> McpResult<String> {
        self.handle_empty_trash().await
    }

    /// **Capture**: Quickly capture anything needing attention. First GTD step - all items start here.
    /// **When**: Something crosses your mind? Capture immediately without thinking.
    /// **Next**: Use list(status="inbox") to review, then update/change_status to organize.
    ///
    /// **ID Naming Guidelines**:
    /// - Use kebab-case (lowercase with hyphens): "fix-io-button", "review-q3-sales"
    /// - Start with verb when possible: "update-", "fix-", "create-", "review-"
    /// - Keep concise but meaningful (3-5 words max)
    /// - Use project prefix for clarity: "eci-fix-button", "fft-level-cloud"
    /// - IDs are immutable - choose carefully as they cannot be changed later
    #[allow(clippy::too_many_arguments)]
    #[tool]
    async fn inbox(
        &self,
        /// Unique string ID - follow kebab-case guidelines above (e.g., "call-john", "web-redesign")
        id: String,
        /// Brief description
        title: String,
        /// inbox | next_action | waiting_for | later | calendar | someday | done | reference | project | context | trash
        status: String,
        /// Optional: Parent project ID
        project: Option<String>,
        /// Optional: Where applies (e.g., "@home", "@office")
        context: Option<String>,
        /// Optional: Markdown notes
        notes: Option<String>,
        /// Optional: YYYY-MM-DD, required for calendar status
        start_date: Option<String>,
        /// Optional: Recurrence pattern - daily | weekly | monthly | yearly
        recurrence: Option<String>,
        /// Optional: Recurrence configuration
        /// - weekly: weekday names (e.g., "Monday,Wednesday,Friday")
        /// - monthly: day numbers (e.g., "1,15,25")
        /// - yearly: month-day pairs (e.g., "1-1,12-25" for Jan 1 and Dec 25)
        recurrence_config: Option<String>,
    ) -> McpResult<String> {
        self.handle_inbox(
            id,
            title,
            status,
            project,
            context,
            notes,
            start_date,
            recurrence,
            recurrence_config,
        )
        .await
    }

    /// **Review**: List/filter all items. Essential for daily/weekly reviews.
    /// **When**: Daily - check next_action. Weekly - review all. Use filters to focus.
    /// **Filters**: No filter=all | status="inbox"=unprocessed | status="next_action"=ready | status="calendar"+date=today's tasks | keyword="text"=search | project="id"=by project | context="name"=by context.
    #[tool]
    async fn list(
        &self,
        /// Optional: Filter by status (inbox | next_action | waiting_for | later | calendar | someday | done | reference | project | context | trash)
        status: Option<String>,
        /// Optional: Date filter YYYY-MM-DD - For calendar, shows tasks with start_date <= this date
        date: Option<String>,
        /// Optional: True to exclude notes and reduce token usage
        exclude_notes: Option<bool>,
        /// Optional: Search keyword in id, title and notes (case-insensitive)
        keyword: Option<String>,
        /// Optional: Filter by project ID - use meaningful abbreviation (e.g., "website-redesign", "q1-budget")
        project: Option<String>,
        /// Optional: Filter by context name
        context: Option<String>,
    ) -> McpResult<String> {
        self.handle_list(status, date, exclude_notes, keyword, project, context)
            .await
    }

    /// **Clarify**: Update item details. Add context, notes, project links after capturing.
    /// **When**: After inbox capture, clarify what it is, why it matters, what's needed.
    /// **Tip**: Use ""(empty string) to clear optional fields.
    /// **Note**: Item ID cannot be changed - IDs are immutable. To "rename", create new item and delete old one.
    #[allow(clippy::too_many_arguments)]
    #[tool]
    async fn update(
        &self,
        /// Item ID to update (immutable - cannot be changed)
        id: String,
        /// Optional: New title
        title: Option<String>,
        /// Optional: New status (changes type if project/context)
        status: Option<String>,
        /// Optional: Project link, ""=clear
        project: Option<String>,
        /// Optional: Context tag, ""=clear
        context: Option<String>,
        /// Optional: Markdown notes, ""=clear
        notes: Option<String>,
        /// Optional: Start date YYYY-MM-DD, ""=clear
        start_date: Option<String>,
    ) -> McpResult<String> {
        self.handle_update(id, title, status, project, context, notes, start_date)
            .await
    }

    /// **Organize/Do**: Move items through workflow stages as you process them.
    /// **When**: inbox→next_action(ready) | →waiting_for(blocked) | →done(complete) | →trash(discard).
    /// **Tip**: Use change_status to trash before empty_trash to permanently delete.
    /// **Batch**: Supports multiple IDs for efficient batch operations (e.g., weekly review).
    #[tool]
    async fn change_status(
        &self,
        /// Item IDs to change - format: ["#1", "#2", "#3"] for batch operations, or single ID for single item
        ids: Vec<String>,
        /// New status: inbox | next_action | waiting_for | later | calendar | someday | done | reference | project | context | trash
        new_status: String,
        /// Optional: Start date YYYY-MM-DD (required for calendar)
        start_date: Option<String>,
    ) -> McpResult<String> {
        self.handle_change_status(ids, new_status, start_date).await
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    use crate::gtd::{Nota, local_date_today};
    use crate::migration::Task;
    use chrono::NaiveDate;
    use mcp_attr::bail_public;
    use tempfile::NamedTempFile;

    fn get_test_handler() -> (GtdServerHandler, NamedTempFile) {
        let temp_file = NamedTempFile::new().unwrap();
        let handler = GtdServerHandler::new(temp_file.path().to_str().unwrap(), false).unwrap();
        (handler, temp_file)
    }


    // ========== INBOX TESTS ==========
    #[cfg(test)]
    mod inbox_tests {
        use super::*;

    #[tokio::test]
    async fn test_inbox_task() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_trash_task_from_inbox() {
        let (handler, _temp_file) = get_test_handler();

        let result = handler
            .inbox(
                "task-22".to_string(),
                "Test Task".to_string(),
                "inbox".to_string(),
                None,
                None,
                None,
                None,
                None,
                None,
            )
            .await;
        assert!(result.is_ok());
        let task_id = validation::extract_id_from_response(&result.unwrap());

        let result = handler
            .change_status(vec![task_id.clone()], "trash".to_string(), None)
            .await;
        assert!(result.is_ok(), "Failed to trash task: {:?}", result.err());

        let data = handler.data.lock().unwrap();
        let task = data.find_task_by_id(&task_id).unwrap();
        assert!(matches!(task.status, NotaStatus::trash));
        assert_eq!(data.trash().len(), 1);
        assert_eq!(data.inbox().len(), 0);
    }
    #[tokio::test]
    async fn test_inbox_tasks_multiple_tasks() {
        let (handler, _temp_file) = get_test_handler();

    }

    // ========== CHANGE_STATUS TESTS ==========
    #[cfg(test)]
    mod change_status_tests {
        use super::*;

    #[tokio::test]
    async fn test_change_task_status_unified_api() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_change_task_status_calendar_with_date() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_change_nota_status_batch_operation() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_batch_change_status_multiple_ids() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_batch_change_status_partial_failure() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_batch_change_status_all_failures() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_batch_change_status_empty_array() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_batch_change_status_to_trash() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_batch_change_status_with_id_normalization() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_batch_change_status_different_initial_statuses() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_status_movement_with_arbitrary_id() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_update_task_status_using_next_action_task() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_next_action_task() {
        let (handler, _temp_file) = get_test_handler();

        let result = handler
            .inbox(
                "task-17".to_string(),
                "Test Task".to_string(),
                "inbox".to_string(),
                None,
                None,
                None,
                None,
                None,
                None,
            )
            .await;
        assert!(result.is_ok());
        let task_id = validation::extract_id_from_response(&result.unwrap());

        let result = handler
            .change_status(vec![task_id.clone()], "next_action".to_string(), None)
            .await;
        assert!(result.is_ok());

        let data = handler.data.lock().unwrap();
        let task = data.find_task_by_id(&task_id).unwrap();
        assert!(matches!(task.status, NotaStatus::next_action));
        assert_eq!(data.next_action().len(), 1);
        assert_eq!(data.inbox().len(), 0);
    }
    #[tokio::test]
    async fn test_waiting_for_task() {
        let (handler, _temp_file) = get_test_handler();

        let result = handler
            .inbox(
                "task-18".to_string(),
                "Test Task".to_string(),
                "inbox".to_string(),
                None,
                None,
                None,
                None,
                None,
                None,
            )
            .await;
        assert!(result.is_ok());
        let task_id = validation::extract_id_from_response(&result.unwrap());

        let result = handler
            .change_status(vec![task_id.clone()], "waiting_for".to_string(), None)
            .await;
        assert!(result.is_ok());

        let data = handler.data.lock().unwrap();
        let task = data.find_task_by_id(&task_id).unwrap();
        assert!(matches!(task.status, NotaStatus::waiting_for));
        assert_eq!(data.waiting_for().len(), 1);
        assert_eq!(data.inbox().len(), 0);
    }
    #[tokio::test]
    async fn test_someday_task() {
        let (handler, _temp_file) = get_test_handler();

        let result = handler
            .inbox(
                "task-19".to_string(),
                "Test Task".to_string(),
                "inbox".to_string(),
                None,
                None,
                None,
                None,
                None,
                None,
            )
            .await;
        assert!(result.is_ok());
        let task_id = validation::extract_id_from_response(&result.unwrap());

        let result = handler
            .change_status(vec![task_id.clone()], "someday".to_string(), None)
            .await;
        assert!(result.is_ok());

        let data = handler.data.lock().unwrap();
        let task = data.find_task_by_id(&task_id).unwrap();
        assert!(matches!(task.status, NotaStatus::someday));
        assert_eq!(data.someday().len(), 1);
        assert_eq!(data.inbox().len(), 0);
    }
    #[tokio::test]
    async fn test_later_task() {
        let (handler, _temp_file) = get_test_handler();

        let result = handler
            .inbox(
                "task-20".to_string(),
                "Test Task".to_string(),
                "inbox".to_string(),
                None,
                None,
                None,
                None,
                None,
                None,
            )
            .await;
        assert!(result.is_ok());
        let task_id = validation::extract_id_from_response(&result.unwrap());

        let result = handler
            .change_status(vec![task_id.clone()], "later".to_string(), None)
            .await;
        assert!(result.is_ok());

        let data = handler.data.lock().unwrap();
        let task = data.find_task_by_id(&task_id).unwrap();
        assert!(matches!(task.status, NotaStatus::later));
        assert_eq!(data.later().len(), 1);
        assert_eq!(data.inbox().len(), 0);
    }
    #[tokio::test]
    async fn test_done_task() {
        let (handler, _temp_file) = get_test_handler();

        let result = handler
            .inbox(
                "task-21".to_string(),
                "Test Task".to_string(),
                "inbox".to_string(),
                None,
                None,
                None,
                None,
                None,
                None,
            )
            .await;
        assert!(result.is_ok());
        let task_id = validation::extract_id_from_response(&result.unwrap());

        let result = handler
            .change_status(vec![task_id.clone()], "done".to_string(), None)
            .await;
        assert!(result.is_ok());

        let data = handler.data.lock().unwrap();
        let task = data.find_task_by_id(&task_id).unwrap();
        assert!(matches!(task.status, NotaStatus::done));
        assert_eq!(data.done().len(), 1);
        assert_eq!(data.inbox().len(), 0);
    }
    #[tokio::test]
    async fn test_calendar_task_with_start_date() {
        let (handler, _temp_file) = get_test_handler();

        let result = handler
            .inbox(
                "task-30".to_string(),
                "Test Task".to_string(),
                "inbox".to_string(),
                None,
                None,
                None,
                None,
                None,
                None,
            )
            .await;
        assert!(result.is_ok());
        let task_id = validation::extract_id_from_response(&result.unwrap());

        let result = handler
            .change_status(
                vec![task_id.clone()],
                "calendar".to_string(),
                Some("2024-12-25".to_string()),
            )
            .await;
        assert!(result.is_ok());

        let data = handler.data.lock().unwrap();
        let task = data.find_task_by_id(&task_id).unwrap();
        assert!(matches!(task.status, NotaStatus::calendar));
        assert_eq!(data.calendar().len(), 1);
        assert_eq!(data.inbox().len(), 0);
        assert!(task.start_date.is_some());
        assert_eq!(
            task.start_date.unwrap(),
            NaiveDate::from_ymd_opt(2024, 12, 25).unwrap()
        );
    }
    #[tokio::test]
    async fn test_calendar_task_without_start_date_error() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_calendar_task_with_existing_start_date() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_calendar_task_override_start_date() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_calendar_task_invalid_date_format() {
        let (handler, _temp_file) = get_test_handler();

        let result = handler
            .inbox(
                "task-32".to_string(),
                "Test Task".to_string(),
                "inbox".to_string(),
                None,
                None,
                None,
                None,
                None,
                None,
            )
            .await;
        assert!(result.is_ok());
        let task_id = validation::extract_id_from_response(&result.unwrap());

    #[tokio::test]
    async fn test_status_movement_updates_timestamp() {
        let (handler, _temp_file) = get_test_handler();

        let result = handler
            .inbox(
                "task-33".to_string(),
                "Test Task".to_string(),
                "inbox".to_string(),
                None,
                None,
                None,
                None,
                None,
                None,
            )
            .await;
        assert!(result.is_ok());
        let task_id = validation::extract_id_from_response(&result.unwrap());

        let created_at = {
            let data = handler.data.lock().unwrap();
            let task = data.find_task_by_id(&task_id).unwrap();
            task.created_at
        };

    #[tokio::test]
    async fn test_status_movement_nonexistent_task() {
        let (handler, _temp_file) = get_test_handler();

        let result = handler
            .change_status(
                vec!["nonexistent-id".to_string()],
                "next_action".to_string(),
                None,
            )
            .await;
        assert!(result.is_err());

        let result = handler
            .change_status(vec!["nonexistent-id".to_string()], "done".to_string(), None)
            .await;
        assert!(result.is_err());

        let result = handler
            .change_status(
                vec!["nonexistent-id".to_string()],
                "trash".to_string(),
                None,
            )
            .await;
        assert!(result.is_err());
    }
    #[tokio::test]
    async fn test_list_displays_completion_date_for_done_tasks() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_next_action_tasks_multiple_tasks() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_waiting_for_tasks_multiple_tasks() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_someday_tasks_multiple_tasks() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_later_tasks_multiple_tasks() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_done_tasks_multiple_tasks() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_change_task_status_invalid_status_error_message() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_change_task_status_various_invalid_statuses() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_calendar_tasks_multiple_tasks_with_date() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_calendar_tasks_with_existing_dates() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_calendar_tasks_partial_failure() {
        let (handler, _temp_file) = get_test_handler();

    }

    // ========== LIST TESTS ==========
    #[cfg(test)]
    mod list_tests {
        use super::*;

    #[tokio::test]
    async fn test_list_contexts_empty() {
        let (handler, _temp_file) = get_test_handler();

        let result = handler.list(None, None, None, None, None, None).await;
        assert!(result.is_ok());
        assert!(result.unwrap().contains("No items found")); // list() returns generic message
    }
    #[tokio::test]
    async fn test_list_contexts() {
        let (handler, _temp_file) = get_test_handler();

        handler
            .inbox(
                "Office".to_string(),
                "Office".to_string(),
                "context".to_string(),
                None,
                None,
                Some("Work environment".to_string()),
                None,
                None,
                None,
            )
            .await
            .unwrap();
        handler
            .inbox(
                "Home".to_string(),
                "Home".to_string(),
                "context".to_string(),
                None,
                None,
                None,
                None,
                None,
                None,
            )
            .await
            .unwrap();

        let result = handler.list(None, None, None, None, None, None).await;
        assert!(result.is_ok());
        let output = result.unwrap();
        assert!(output.contains("Office"));
        assert!(output.contains("Home"));
        assert!(output.contains("Work environment"));
    }
    #[tokio::test]
    async fn test_list_tasks_without_date_filter_shows_all_tasks() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_list_tasks_with_date_filter_includes_same_date() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_list_tasks_includes_notes_by_default() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_list_tasks_includes_notes_when_explicitly_false() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_list_tasks_with_multiline_notes() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_list_displays_timestamps() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_list_tasks_invalid_status_error_message() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_list_tasks_various_invalid_statuses() {
        let (handler, _temp_file) = get_test_handler();

        let invalid_statuses = vec!["invalid", "complete", "pending", "INBOX"];

        for invalid_status in invalid_statuses {
            let result = handler
                .list(
                    Some(invalid_status.to_string()),
                    None,
                    None,
                    None,
                    None,
                    None,
                )
                .await;
            assert!(
                result.is_err(),
                "Expected error for invalid status: {}",
                invalid_status
            );
            let err_msg = format!("{:?}", result.unwrap_err());
            assert!(
                err_msg.contains(&format!("Invalid status '{}'", invalid_status)),
                "Error message should contain the invalid status '{}'",
                invalid_status
            );
        }
    }
    #[tokio::test]
    async fn test_list_with_date_filter_basic() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_list_with_date_filter_only_applies_to_calendar() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_list_with_date_filter_calendar_without_start_date() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_list_with_invalid_date_format() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_list_with_exclude_notes() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_list_with_date_and_status_filter_combined() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_list_with_date_filter_and_exclude_notes() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_list_with_keyword_filter_in_title() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_list_with_keyword_filter_in_notes() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_list_with_keyword_filter_case_insensitive() {
        let (handler, _temp_file) = get_test_handler();

        handler
            .inbox(
                "task-1".to_string(),
                "Study TRITON paper".to_string(),
                "inbox".to_string(),
                None,
                None,
                None,
                None,
                None,
                None,
            )
            .await
            .unwrap();

    #[tokio::test]
    async fn test_list_with_keyword_filter_checks_both_title_and_notes() {
        let (handler, _temp_file) = get_test_handler();

        handler
            .inbox(
                "task-1".to_string(),
                "Task with keyword in title".to_string(),
                "inbox".to_string(),
                None,
                None,
                Some("Regular notes".to_string()),
                None,
                None,
                None,
            )
            .await
            .unwrap();
        handler
            .inbox(
                "task-2".to_string(),
                "Regular title".to_string(),
                "inbox".to_string(),
                None,
                None,
                Some("Notes with keyword here".to_string()),
                None,
                None,
                None,
            )
            .await
            .unwrap();
        handler
            .inbox(
                "task-3".to_string(),
                "Unrelated task".to_string(),
                "inbox".to_string(),
                None,
                None,
                Some("Other notes".to_string()),
                None,
                None,
                None,
            )
            .await
            .unwrap();

    #[tokio::test]
    async fn test_list_with_keyword_filter_in_id() {
        let (handler, _temp_file) = get_test_handler();

        handler
            .inbox(
                "fft-algorithm".to_string(),
                "Implement algorithm".to_string(),
                "inbox".to_string(),
                None,
                None,
                None,
                None,
                None,
                None,
            )
            .await
            .unwrap();
        handler
            .inbox(
                "web-redesign".to_string(),
                "Redesign website".to_string(),
                "inbox".to_string(),
                None,
                None,
                None,
                None,
                None,
                None,
            )
            .await
            .unwrap();
        handler
            .inbox(
                "meeting-notes".to_string(),
                "Take notes".to_string(),
                "inbox".to_string(),
                None,
                None,
                None,
                None,
                None,
                None,
            )
            .await
            .unwrap();

    #[tokio::test]
    async fn test_list_with_project_filter() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_list_with_context_filter() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_list_with_status_and_keyword_filters() {
        let (handler, _temp_file) = get_test_handler();

        handler
            .inbox(
                "task-1".to_string(),
                "TRITON task in inbox".to_string(),
                "inbox".to_string(),
                None,
                None,
                None,
                None,
                None,
                None,
            )
            .await
            .unwrap();
        handler
            .inbox(
                "task-2".to_string(),
                "Other task in inbox".to_string(),
                "inbox".to_string(),
                None,
                None,
                None,
                None,
                None,
                None,
            )
            .await
            .unwrap();
        handler
            .inbox(
                "task-3".to_string(),
                "TRITON task for next".to_string(),
                "next_action".to_string(),
                None,
                None,
                None,
                None,
                None,
                None,
            )
            .await
            .unwrap();

    #[tokio::test]
    async fn test_list_with_project_and_context_filters() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_list_with_all_filters_combined() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_list_with_filters_no_matches() {
        let (handler, _temp_file) = get_test_handler();

        handler
            .inbox(
                "task-1".to_string(),
                "Task 1".to_string(),
                "inbox".to_string(),
                None,
                None,
                None,
                None,
                None,
                None,
            )
            .await
            .unwrap();

    }

    // ========== UPDATE TESTS ==========
    #[cfg(test)]
    mod update_tests {
        use super::*;

    #[tokio::test]
    async fn test_update_task_with_arbitrary_id() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_update_task_title() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_update_task_project_and_context() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_update_task_remove_optional_fields() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_update_task_invalid_date() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_update_task_invalid_project_reference() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_update_task_invalid_context_reference() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_update_task_not_found() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_update_task_updates_timestamp() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_update_project_name() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_update_project_description() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_update_project_invalid_status() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_update_project_not_found() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_update_multiple_fields_simultaneously() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_update_context() {
        let (handler, _temp_file) = get_test_handler();

        handler
            .inbox(
                "Office".to_string(),
                "Office".to_string(),
                "context".to_string(),
                None,
                None,
                Some("Old description".to_string()),
                None,
                None,
                None,
            )
            .await
            .unwrap();

        let result = handler
            .update(
                "Office".to_string(),
                None,
                None,
                None,
                None,
                Some("New description".to_string()),
                None,
            )
            .await;
        assert!(result.is_ok());

        let data = handler.data.lock().unwrap();
        let context = data.find_context_by_name("Office").unwrap();
        assert_eq!(context.notes, Some("New description".to_string()));
    }
    #[tokio::test]
    async fn test_update_context_remove_description() {
        let (handler, _temp_file) = get_test_handler();

        handler
            .inbox(
                "Office".to_string(),
                "Office".to_string(),
                "context".to_string(),
                None,
                None,
                Some("Old description".to_string()),
                None,
                None,
                None,
            )
            .await
            .unwrap();

        let result = handler
            .update(
                "Office".to_string(),
                None,
                None,
                None,
                None,
                Some("".to_string()),
                None,
            )
            .await;
        assert!(result.is_ok());

        let data = handler.data.lock().unwrap();
        let context = data.find_context_by_name("Office").unwrap();
        assert_eq!(context.notes, None);
    }
    #[tokio::test]
    async fn test_update_context_not_found() {
        let (handler, _temp_file) = get_test_handler();

        let result = handler
            .update(
                "NonExistent".to_string(),
                None,
                None,
                None,
                None,
                Some("Description".to_string()),
                None,
            )
            .await;
        assert!(result.is_err());
    }
    #[tokio::test]
    async fn test_update_project_context() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_update_project_remove_context() {
        let (handler, _temp_file) = get_test_handler();

    }

    // ========== EMPTY_TRASH TESTS ==========
    #[cfg(test)]
    mod empty_trash_tests {
        use super::*;

    #[tokio::test]
    async fn test_trash_task_workflow_comparison() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_trash_task_error_messages() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_trash_notas_multiple() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_trash_notas_partial_success() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_trash_tasks_all_invalid() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_trash_notas_from_different_statuses() {
        let (handler, _temp_file) = get_test_handler();

    }

    // ========== OTHER_HANDLERS TESTS ==========
    #[cfg(test)]
    mod other_handlers_tests {
        use super::*;

    #[tokio::test]
    async fn test_delete_project_success() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_delete_project_not_found() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_delete_project_with_task_reference() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_delete_project_after_unlinking_tasks() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_add_context() {
        let (handler, _temp_file) = get_test_handler();

        let result = handler
            .inbox(
                "Office".to_string(),
                "Office".to_string(),
                "context".to_string(),
                None,
                None,
                Some("Work environment".to_string()),
                None,
                None,
                None,
            )
            .await;
        assert!(result.is_ok());
        assert!(result.unwrap().contains("Office"));

        let data = handler.data.lock().unwrap();
        assert_eq!(data.contexts().len(), 1);
        let context = data.find_context_by_name("Office").unwrap();
        assert_eq!(context.id, "Office");
        assert_eq!(context.notes, Some("Work environment".to_string()));
    }
    #[tokio::test]
    async fn test_add_context_duplicate() {
        let (handler, _temp_file) = get_test_handler();

        let result = handler
            .inbox(
                "Office".to_string(),
                "Office".to_string(),
                "context".to_string(),
                None,
                None,
                None,
                None,
                None,
                None,
            )
            .await;
        assert!(result.is_ok());

    #[tokio::test]
    async fn test_delete_context() {
        let (handler, _temp_file) = get_test_handler();

        handler
            .inbox(
                "Office".to_string(),
                "Office".to_string(),
                "context".to_string(),
                None,
                None,
                None,
                None,
                None,
                None,
            )
            .await
            .unwrap();

        let result = handler
            .change_status(vec!["Office".to_string()], "trash".to_string(), None)
            .await;
        assert!(result.is_ok());
        let result = handler.empty_trash().await;
        assert!(result.is_ok());

        let data = handler.data.lock().unwrap();
        assert_eq!(data.contexts().len(), 0);
    }
    #[tokio::test]
    async fn test_delete_context_not_found() {
        let (handler, _temp_file) = get_test_handler();

        let result = handler
            .change_status(vec!["NonExistent".to_string()], "trash".to_string(), None)
            .await;
        assert!(result.is_err());
    }
    #[tokio::test]
    async fn test_delete_context_with_task_reference() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_delete_context_with_project_reference() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_delete_context_with_both_task_and_project_references() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_delete_context_after_removing_task_reference() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_delete_context_after_removing_project_reference() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_delete_context_with_multiple_task_references() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_add_project_with_context() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_add_project_with_invalid_context() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_add_project_with_custom_id() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_add_project_with_duplicate_id() {
        let (handler, _temp_file) = get_test_handler();

    }

    // ========== INFRASTRUCTURE TESTS ==========
    #[cfg(test)]
    mod infrastructure_tests {
        use super::*;

    #[test]
    fn test_custom_file_path() {
    #[test]
    fn test_normalize_task_id() {
    #[tokio::test]
    async fn test_invalid_project_reference_error_message() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_invalid_project_reference_with_available_projects() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_invalid_context_reference_error_message() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_invalid_context_reference_with_available_contexts() {
        let (handler, _temp_file) = get_test_handler();

    #[tokio::test]
    async fn test_mcp_duplicate_id_error_response() {
        let (handler, _temp) = get_test_handler();

    #[tokio::test]
    async fn test_mcp_duplicate_id_across_statuses() {
        let (handler, _temp) = get_test_handler();

    #[tokio::test]
    async fn test_mcp_error_response_format() {
        let (handler, _temp) = get_test_handler();

    #[tokio::test]
    async fn test_mcp_comprehensive_duplicate_scenarios() {
        let (handler, _temp) = get_test_handler();

        println!("\n=== MCP Protocol Test: Comprehensive Duplicate ID Scenarios ===\n");

    #[tokio::test]
    async fn test_mcp_error_message_quality() {
        let (handler, _temp) = get_test_handler();

    #[tokio::test]
    async fn test_bail_vs_bail_public_comparison() {
        use anyhow::bail;

    }

    // ========== COMMENTED OUT TESTS ==========
        // カスタムファイルパスでハンドラーを作成
        // ストレージのファイルパスが正しく設定されていることを確認
        // データの保存と読み込みが正しく動作することを確認
        // 保存
        // ファイルが作成されていることを確認
        // 新しいハンドラーで読み込み
        // Test with arbitrary task IDs - normalize should just trim
        // Test with whitespace - should be trimmed
        // Old-style IDs with # are also valid
        // Create a task in inbox
        // Test moving to next_action
        // Test moving to done
        // Test moving to trash
        // Test invalid status
        // Create a task
        // Test moving to calendar with date
        // Create multiple tasks
        // Test batch move to next_action
        // Verify all tasks moved
        // Create multiple tasks
        // Batch change status to done
        // Verify all tasks moved to done
        // Create one valid task
        // Try to change status for mix of valid and invalid IDs
        // Should succeed because at least one item succeeded
        // Verify the valid task was moved
        // Try to change status for all invalid IDs
        // Should fail because all items failed
        // Try to change status with empty array
        // Should fail
        // Create multiple tasks
        // Batch move to trash
        // Verify all tasks moved to trash
        // Create tasks and get their actual IDs
        // Change status using both IDs
        // Verify both tasks were updated
        // Create tasks in different statuses
        // Batch change all to done
        // Verify all tasks are now done
        // Add a task with an arbitrary ID
        // Update task using the arbitrary ID
        // Verify the update worked
        // Add a task with an arbitrary ID
        // Move to next_action using the arbitrary ID
        // Verify the task moved
        // Add a task
        // Extract task ID from result
        // Update title
        // Verify update
        // Add a task
        // Verify initial status is inbox
        // Update status to next_action using new method
        // Verify status changed and task moved
        // Add a project and context first
        // Add a task
        // Update project and context
        // Verify update
        // Add a task with optional fields
        // Verify initial state
        // Remove optional fields using empty strings
        // Verify fields removed
        // Add a task
        // Try to update with invalid date
        // Add a task
        // Try to update with non-existent project
        // Add a task
        // Try to update with non-existent context
        // Try to update non-existent task
        // Add a task
        // Get initial timestamps
        // Update task
        // Verify updated_at changed but created_at didn't
        // Note: In test environment, if executed fast enough, updated_at might be the same
        // This is acceptable as the implementation is correct
        // Add a project
        // Update name
        // Verify update
        // Add a project
        // Add description
        // Verify description added
        // Remove description
        // Verify description removed
        // Add a project
        // Try to update with invalid status
        // Try to update non-existent project
        // Add a project
        // Delete the project
        // Verify the project was deleted
        // Try to delete non-existent project
        // Add a project
        // Add a task that references the project
        // Try to delete the project (should fail)
        // Verify the project was NOT deleted
        // Add a project
        // Add a task that references the project
        // Unlink the task from the project
        // Now delete the project (should succeed)
        // Verify the project was deleted
        // Add a project
        // Add a context
        // Add a task
        // Update multiple fields at once
        // Change status separately using new method
        // Verify all updates
    // Tests for new status movement methods
        // Add a task
        // Move to next_action first
        // Verify it's in next_action
        // Move back to inbox
        // Verify it's back in inbox
        // Test 1: inbox → trash directly
        // Test 2: inbox → done → trash (the workflow user reported as working)
        // Verify both tasks ended up in trash
        // Test with various invalid task IDs to ensure error handling works
        // 複数のタスクを作成
        // 複数のタスクを一度にtrashに移動
        // すべてのタスクがtrashに移動されたことを確認
        // 有効なタスクを2つ作成
        // 無効なタスクIDを追加
        // 有効なタスクだけをtrashに移動
        // 部分的な成功を確認
        // 有効なタスクだけがtrashに移動されたことを確認
        // すべて無効なタスクID
        // すべて失敗する場合はエラーを返す
        // inboxからタスクを作成
        // next_actionに移動
        // doneに移動
        // 異なるステータスのタスクを一度にtrashに移動
        // All tasks successfully moved to trash
        // すべてがtrashに移動されたことを確認
        // タスクを作成（start_dateなし）
        // start_dateを指定せずにcalendarに移動しようとするとエラー
        // start_date付きのタスクを作成
        // start_dateパラメータなしでcalendarに移動（既存のstart_dateを使用）
        // start_date付きのタスクを作成
        // 新しいstart_dateを指定してcalendarに移動（既存のstart_dateを上書き）
        // 無効な日付形式
        // Move to next_action
        // Verify created_at unchanged
    // Tests for context management
        // Try to add duplicate
        // Add a context
        // Add a task that references the context
        // Try to delete the context - should fail
        // Verify context still exists
        // Add a context
        // Add a project that references the context
        // Try to delete the context - should fail
        // Verify context still exists
        // Add a context
        // Add a task that references the context
        // Add a project that references the context
        // Try to delete the context - should fail (task check comes first)
        // Verify context still exists
        // Add a context
        // Add a task that references the context
        // Extract task ID from the response
        // Remove the context reference from the task
        // Now deletion should succeed
        // Verify context is gone
        // Add a context
        // Add a project that references the context
        // Remove the context reference from the project
        // Now deletion should succeed
        // Verify context is gone
        // Add a context
        // Add multiple tasks that reference the context
        // Try to delete the context - should fail with the first task found
        // Verify context still exists
        // Add a context first
        // Add a project with context
        // Verify project has context
        // Try to add project with non-existent context
        // Add a context
        // Add a project without context
        // Update project with context
        // Verify context added
        // Add a context
        // Add a project with context
        // Remove context using empty string
        // Verify context removed
        // Add a project with custom ID
        // Verify project was created with custom ID
        // Add first project with custom ID
        // Try to add second project with same ID
        // Verify error message is specific about duplicate ID
        // Try to add task with non-existent project (when no projects exist)
        // Verify error message mentions the non-existent project and explains no projects exist
        // First create some projects
        // Try to add task with non-existent project
        // Verify error message lists available projects
        // Try to add task with non-existent context (when no contexts exist)
        // Verify error message mentions the non-existent context and explains no contexts exist
        // First create some contexts
        // Try to add task with non-existent context
        // Verify error message lists available contexts
    // ==================== Prompt Tests ====================
    // GTD workflow methods removed - tests commented out
    /*
    #[tokio::test]
    async fn test_prompt_gtd_overview() {
        let (handler, _temp_file) = get_test_handler();

        let result = handler.gtd_overview().await;
        assert!(result.is_ok());
        let content = result.unwrap();

        // プロンプトが主要なGTDコンセプトを含んでいることを確認
        assert!(content.contains("GTD"));
        assert!(content.contains("inbox"));
        assert!(content.contains("next_action"));
        assert!(content.contains("waiting_for"));
        assert!(content.contains("someday"));
        assert!(content.contains("calendar"));
        assert!(content.contains("done"));
        assert!(content.contains("trash"));
        assert!(content.contains("Projects"));
        assert!(content.contains("Contexts"));
    }

    #[tokio::test]
    async fn test_prompt_process_inbox() {
        let (handler, _temp_file) = get_test_handler();

        let result = handler.process_inbox().await;
        assert!(result.is_ok());
        let content = result.unwrap();

        // インボックス処理のワークフローガイダンスを確認
        assert!(content.contains("inbox"));
        assert!(content.contains("actionable"));
        assert!(content.contains("2 minutes"));
        assert!(content.contains("waiting_for"));
        assert!(content.contains("next_action"));
    }

    #[tokio::test]
    async fn test_prompt_weekly_review() {
        let (handler, _temp_file) = get_test_handler();

        let result = handler.weekly_review().await;
        assert!(result.is_ok());
        let content = result.unwrap();

        // 週次レビューのステップを確認
        assert!(content.contains("Weekly Review"));
        assert!(content.contains("Get Clear"));
        assert!(content.contains("Get Current"));
        assert!(content.contains("Projects"));
        assert!(content.contains("calendar"));
        assert!(content.contains("next_action"));
        assert!(content.contains("waiting_for"));
    }

    #[tokio::test]
    async fn test_prompt_next_actions() {
        let (handler, _temp_file) = get_test_handler();

        let result = handler.next_actions().await;
        assert!(result.is_ok());
        let content = result.unwrap();

        // ネクストアクションガイドの内容を確認
        assert!(content.contains("Next Actions"));
        assert!(content.contains("Context"));
        assert!(content.contains("@office"));
        assert!(content.contains("@computer"));
        assert!(content.contains("@phone"));
        assert!(content.contains("Specific"));
    }

    #[tokio::test]
    #[tokio::test]
    async fn test_prompts_return_non_empty_strings() {
        let (handler, _temp_file) = get_test_handler();

        // 全てのプロンプトが空でない文字列を返すことを確認
        let prompts = vec![
            handler.gtd_overview().await,
            handler.process_inbox().await,
            handler.weekly_review().await,
            handler.next_actions().await,
            handler.add_task_guide().await,
        ];

        for prompt in prompts {
            assert!(prompt.is_ok());
            let content = prompt.unwrap();
            assert!(!content.is_empty());
            assert!(content.len() > 100); // 各プロンプトは実質的な内容を持つ
        }
    }
    */
    // 日付フィルタリングのテスト: 日付フィルタなしでは全タスク表示
        // 未来の日付のタスクを作成
        // 日付フィルタなしで一覧取得
        // 未来のタスクも表示される
    // 日付フィルタリングのテスト: start_dateが指定日と同じ場合は表示される
        // 指定日と同じ日付のタスクを作成
        // 同じ日付でフィルタリング
        // 同じ日付のタスクは表示される（未来ではない）
    // notesフィールドがlist_tasksの出力に含まれることを確認
        // notesを持つタスクを作成
        // notesなしのタスクも作成
        // デフォルト（exclude_notes=None）で一覧取得
        // notesが含まれていることを確認
        // notesなしのタスクにはnotesフィールドがないことを確認
    // exclude_notes=falseで明示的にnotesを含めることを確認
        // notesを持つタスクを作成
        // exclude_notes=falseで明示的に一覧取得
        // notesが含まれていることを確認
    // notesに複数行やspecial charactersが含まれる場合のテスト
        // 複数行のnotesを持つタスクを作成（改行を含む）
        // デフォルトで一覧取得
        // notesが含まれていることを確認（改行も含む）
    // タイムスタンプ表示のテスト: list出力にcreated_atとupdated_atが含まれることを確認
        // タスクを作成
        // 一覧取得
        // タイムスタンプが含まれていることを確認
        // 日付形式を確認（YYYY-MM-DDの形式）
        // Print the output for manual verification
    // タイムスタンプ表示のテスト: 完了タスクの完了日がupdated_atで確認できることを検証
        // タスクを作成
        // タスクをdoneに変更（完了）
        // 一覧取得（status=doneでフィルタ）
        // 完了タスクがリストに含まれることを確認
        // Updated フィールドが表示されていることを確認（完了日として使用可能）
        // Print the output for manual verification
        // 複数のタスクを作成してnext_actionに移動
            // Move to next_action first
        // 複数のタスクを一度にinboxに移動
        // すべてのタスクがinboxに移動されたことを確認
        // 複数のタスクを作成
        // 複数のタスクを一度にnext_actionに移動
        // すべてのタスクがnext_actionに移動されたことを確認
        // 複数のタスクを作成
        // 複数のタスクを一度にwaiting_forに移動
        // すべてのタスクがwaiting_forに移動されたことを確認
        // 複数のタスクを作成
        // 複数のタスクを一度にsomedayに移動
        // すべてのタスクがsomedayに移動されたことを確認
        // 複数のタスクを作成
        // 複数のタスクを一度にlaterに移動
        // すべてのタスクがlaterに移動されたことを確認
        // 複数のタスクを作成
        // 複数のタスクを一度にdoneに移動
        // すべてのタスクがdoneに移動されたことを確認
    // ==================== Invalid Status Error Message Tests ====================
        // タスクを作成
        // 無効なステータス "in_progress" でエラーをテスト（問題として報告されたもの）
        // タスクを作成
        // 様々な無効なステータスをテスト
        // 無効なステータスでリストを取得しようとする
        // 複数のタスクを作成
        // 複数のタスクを一度にcalendarに移動（start_date指定）
        // すべてのタスクがcalendarに移動されたことを確認
        // start_dateを持つタスクを作成
        // start_dateを指定せずにcalendarに移動（既存のstart_dateを使用）
        // すべてのタスクがcalendarに移動され、既存のstart_dateが保持されていることを確認
        // start_dateを持つタスクと持たないタスクを作成
        // start_dateを持つタスク
        // start_dateを持たないタスク
        // start_dateを指定せずに移動を試みる（部分的な失敗）
        // First task has date, should succeed
        // Second task has no date, should fail
        // 1つのタスクだけが移動されたことを確認
    // テスト: date フィルタリングの基本機能
        // calendar ステータスの複数のタスクを作成
        // 過去のタスク
        // 今日のタスク
        // 未来のタスク
        // フィルタ日: 2024-06-15 として、それ以前のタスクのみ表示
        // 過去と今日のタスクのみ表示される
    // テスト: date フィルタは calendar ステータスのみに適用される
        // calendar 以外のステータスで未来の start_date を持つタスク
        // calendar ステータスで未来の start_date を持つタスク
        // 現在の日付でフィルタリング（2024-06-15）
        // inbox と next_action のタスクは date に関係なく表示される
        // calendar の未来タスクは非表示
    // テスト: start_date が None の calendar タスクは常に表示される
        // start_date なしの calendar タスク（本来は calendar には start_date が必要だが、
        // データが古い場合や何らかの理由で start_date がない場合を考慮）
        // 注: inbox で作成後に change_status で calendar に移動する方法は使えないため、
        // 直接データを操作する必要があるが、テストのためここでは inbox で作成
        // inbox から calendar に手動で移動（start_date なし）
        // change_status は calendar に start_date を要求するため、直接データを操作
        // 未来の日付でフィルタリング
        // start_date なしのタスクは常に表示される
    // テスト: 無効な date フォーマット
        // 無効な日付フォーマット
        // もう一つの無効なフォーマット
    // テスト: exclude_notes パラメータ
        // ノート付きのタスクを作成
        // ノートを含めてリスト（デフォルト）
        // ノートを除外してリスト
        // 明示的に false を指定してノートを含める
    // テスト: date フィルタと status フィルタの併用
        // 複数のステータスでタスクを作成
        // calendar ステータスで日付フィルタ
    // テスト: date フィルタと exclude_notes の併用
        // ノート付きの calendar タスクを作成
        // date フィルタと exclude_notes を同時に使用
        // 過去のタスクは表示されるが、ノートは表示されない
        // 未来のタスクは非表示
    // ============================================================================
    // MCP Protocol-Level Tests for Issue #190
    // ============================================================================
    //
    // These tests verify the MCP server's behavior at the protocol level,
    // specifically testing error responses and ensuring they are properly
    // formatted for MCP clients.
    //
    // Issue #190: Need to confirm that duplicate ID errors are properly
    // returned to MCP clients with the correct error format.
    /// Test MCP protocol response when duplicate ID is detected
    ///
    /// This test verifies issue #190: when a duplicate ID is provided to the inbox() method,
    /// the server should return a proper error response that includes:
    /// 1. Clear error message indicating duplicate ID
    /// 2. The existing status of the duplicate ID
    /// 3. Guidance on what the user should do
    ///
    /// The error should be returned via McpResult::Err and be visible to the MCP client.
        // Step 1: Create initial item with ID "test-task-1"
        // Verify first creation succeeds
        // Step 2: Attempt to create another item with the same ID "test-task-1"
        // Step 3: Verify duplicate ID error is properly returned
        // Verify error message contains key information
        // Assertions to verify error message quality
        // Additional verification: The error is a public error (visible to MCP client)
        // This is ensured by using bail_public! in the implementation
    /// Test MCP protocol response when duplicate ID exists across different statuses
    ///
    /// This test verifies that duplicate detection works across all nota types
    /// (tasks, projects, contexts) and properly reports the existing status.
        // Create a task with ID "duplicate-test"
        // Try to create a project with the same ID
        // Verify error
        // Verify error mentions the existing status (next_action)
    /// Test MCP protocol response format matches expectations
    ///
    /// This test documents the exact format of error responses to help
    /// diagnose any client-side issues (related to issue #190).
        // Create initial item
        // Trigger duplicate error
        // The error should be a properly formatted McpError that can be
        // serialized to JSON-RPC error response by the MCP framework
    /// Comprehensive test of multiple duplicate ID scenarios
    ///
    /// This test exercises various duplicate ID scenarios to ensure
    /// all error paths are working correctly.
        // Scenario 1: Simple duplicate in inbox
        // Scenario 2: Duplicate after status change
        // Scenario 3: Project ID collision
        // Scenario 4: Context ID collision
    /// Test that verifies error messages are user-friendly and actionable
    ///
    /// This test ensures the error messages follow best practices:
    /// - State what went wrong
    /// - Explain why it's a problem
    /// - Suggest how to fix it
        // Create initial task
        // Trigger duplicate error
        // Check for key components of a good error message
    /// Test to verify the difference between bail! and bail_public!
    ///
    /// This test addresses the question in PR comment #3450783685:
    /// Does bail_public! actually make a difference compared to bail!?
    ///
    /// We'll test both macros to see if they produce different message_is_public flags.
        // Helper function that uses regular bail! (from anyhow)
            // This would normally be an anyhow::Result, but we need to return McpResult
            // So we'll use anyhow's bail in a different way
            // Convert anyhow error to MCP error
                    // When we convert an anyhow error to MCP error, what happens?
                    // Let's use the MCP error creation
        // Helper function that uses bail_public!
        // Test bail! (via anyhow)
        // Test bail_public!
        // Compare the message_is_public flag
        // Assertions to ensure the test validates what we expect
    // ============================================================================
    // Tests for New Filtering Features (keyword, project, context)
    // ============================================================================
    // テスト: keyword フィルタ - タイトルで検索
        // タスクを追加
        // "TRITON"で検索
    // テスト: keyword フィルタ - ノートで検索
        // タスクを追加（ノート付き）
        // "FFT"で検索（ノート内を検索）
    // テスト: keyword フィルタ - 大文字小文字を区別しない
        // 小文字で検索
    // テスト: keyword フィルタ - タイトルとノートの両方をチェック
        // "keyword"で検索
    // テスト: keyword フィルタ - IDで検索
        // "fft"で検索（ID内を検索）
    // テスト: project フィルタ
        // プロジェクトを作成
        // タスクを追加（プロジェクト付き）
        // "FFT"プロジェクトでフィルタ
    // テスト: context フィルタ
        // コンテキストを作成
        // タスクを追加（コンテキスト付き）
        // "仕事"コンテキストでフィルタ
    // テスト: 複数フィルタの組み合わせ (status + keyword)
        // status="inbox" かつ keyword="TRITON"
    // テスト: 複数フィルタの組み合わせ (project + context)
        // プロジェクトとコンテキストを作成
        // タスクを追加
        // project="FFT" かつ context="仕事"
    // テスト: すべてのフィルタの組み合わせ (status + keyword + project + context)
        // プロジェクトとコンテキストを作成
        // タスクを追加
        // すべてのフィルタを適用: status="next_action", keyword="TRITON", project="FFT", context="仕事"
    // テスト: フィルタに一致するアイテムがない場合
        // 存在しないキーワードで検索

}
